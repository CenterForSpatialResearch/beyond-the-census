// colors (mapzen?)
// dot density

extends layout

block content
    #map-container
      #globe-target
      #map-target
    
    #text-container
      #text-target

    
    script(type='text/javascript').
        /******************************** SETUP ********************************/
        // data containers (searchoptions is for fuzzy text search...)
        var input = {
            'filterstring': '',
            'filtertype': 'langname'
          }, searchOptions = {
              extract: function(el) { return el.language; }
          }, data = {
            languages: [],
            countries: [],
            neighborhoods: [],
            selected: {}
          }, map;
        /***************************** MAIN FUNCTION ***************************/
        // fetch data and draw
        updateData( input.filtertype, input.filterstring, () => {
          updateList();
          draw();
        });
        /***************************** EVENT LISTENERS *************************/
        d3.select('#filtertext') 
            .on('input', function () {
              input.filterstring = d3.select(this).property('value');
              var q = d3.queue();
              //q.defer(delayedHello);
              q.defer( updateData, input.filtertype, input.filterstring );
              q.await(function(error) {
                if (error) throw error;
                draw();
                
              });              
            });
        /***************************** DRAW FUNCTIONS **************************/    
        function draw() { // calls group of draw functions, now just updateMap
          addLeafletMap();
          updateMap();
        }
        
        function updateList() { // show text details for highlighted language
          // setup
          var textTarget = d3.select('#text-target');
          var languageList = data.languages;
          
          var languageNest = d3.nest()
            .key(function(d) {return d.continents[0].properties.CONTINENT;})
            .sortKeys(d3.ascending)
            .key(function(d) {return d.endangermentNum;})
            .sortKeys(d3.ascending)
            .entries(data.languages);

          var uniqueContinents = d3.set(languageList, (item) => {
              return item.continents[0].properties.CONTINENT
            }).values();
                    
          // begin DOM manipulation   
          textTarget.selectAll('*').remove(); // clear container on refresh

          var continentItem = textTarget.selectAll('div')
              .data(languageNest)
            .enter().append('div')
              .attr('class', 'continent-item') // makes a list item for every group in the first level of the nest (continent)
              
          continentItem.datum( (d, i, n) => { // calculate color per continent and insert into child elements
            var dModified = d;
            var numContinents = n.length
            var hMap = d3.scaleLinear()
                .domain([0, numContinents])
                .range([0, 300]);
            dModified.color = d3.color( `hsl(${hMap(i)}, 80%, 50%)` );
            
            dModified.values.map( (item) => {
              var itemModified = item;
              itemModified.values.map( (subItem => {
                var subItemModified = subItem;
                subItemModified.continentColor = dModified.color;
                return subItemModified;
              }));
              return itemModified;
            })
            return dModified;
          })
                  
          continentItem.append("div") // label each continent item
              .attr('class', 'continent-item-label')
              .style('background', 'black')
              .style('color', 'white')                    
              .append('p')
              .text((d) => { return d.key });
              
          var languageList = continentItem.append("div") // make container for language list
              .attr('class', 'language-list')
              
          var endangermentItem = languageList.selectAll("div")
              .data( (d) => { return d.values} )
              .enter();
              
          var languageItem = endangermentItem.selectAll("span")
              .data( (d) => { return d.values } )
              .enter().append("span")
              .attr('class', 'language-item')
              .text((d) => {return d.language})
              .style('background', (d, i, n) => {
                var lMap = d3.scaleLinear()
                    .domain([0, 9])
                    .range([0.5, 1]);
                var colorAdjusted = d.continentColor
                colorAdjusted.l = lMap(d.endangermentNum)
                return colorAdjusted;
              })
              .style('color', (d, i, n) => {
                var lMap = d3.scaleLinear()
                    .domain([0, 9])
                    .range([0.5, 1]);
                var colorAdjusted = d.continentColor
                colorAdjusted.l = 0.2

                return colorAdjusted;
              })              
              .on('mouseover', (d, i, n) => {
                      updateGlobe(d);
                                        
                      d3.select('.neighborhood-centers').selectAll('g').selectAll('*').remove(); // clear all other line/label group contents

                      var listItemPoint = [],
                          mapPoint = [],
                          globePoint = [];

                      var listItemBounds = d3.select( n[i] )._groups[0][0].getBoundingClientRect();
                      //console.log(listItemBounds);
                      listItemPoint = [listItemBounds.left, listItemBounds.top + (listItemBounds.height/2) ];
                      
                      globePoint = parseTransform(d3.select('.globe-container').attr('transform')).translate;
                      
                      //console.log(n[i])
                                            
                      d.neighborhoods.forEach( (item, index) => {
                        let itemElement = d3.select(`#ID${item}`);
                        mapPoint[0] = parseTransform(itemElement.attr('transform')).translate[0];
                        mapPoint[1] = parseTransform(itemElement.attr('transform')).translate[1];
                        
                        var lMap = d3.scaleLinear()
                            .domain([0, 9])
                            .range([0.5, 1]);
                        var colorAdjusted = d.continentColor
                        colorAdjusted.l = lMap(d.endangermentNum)
                                                
                        connectTwoElements( item, listItemPoint , mapPoint, colorAdjusted.rgb() ) // draw line between two elements on mouseover
                        connectTwoElements( item, globePoint, mapPoint, colorAdjusted.rgb() ) // draw line between two elements on mouseover
                        
                      });
                    })

            

              
            
        }
        
        function addLeafletMap() {
            map = new L.Map('map-target', {zoomControl: false, attributionControl: false}).setView([40.67, -73.78], 11);
            Tangram.leafletLayer({ scene: '../scene.yaml' }).addTo(map);
            L.svg().addTo(map);
        }
        
        function updateMap() {
                    
            var neighborhoodsAll = {
                type: 'FeatureCollection',
                features: data.neighborhoods.filter( (neighborhood) => {
                  return neighborhood.properties.BoroCode == 4;
                })
            };
          
            var svg = d3.select('#map-target').select('svg'); 
            
            svg.attr("width", window.innerWidth)
              .attr("height", window.innerHeight);
              
            var transform = d3.geoTransform({point: projectPoint});
          	var path = d3.geoPath().projection(transform);
            var pointPath = d3.geoPath().projection(transform).pointRadius('1');

            var width = window.innerWidth, 
                height = window.innerHeight;
                                                            
            /*var neighborhoodCenters = svg.append("g")
                .attr("class", "neighborhood-centers")
              .selectAll("g")
                .data(neighborhoodsAll.features)
              .enter().append("g")
                .attr("id", (d) => { return 'ID' + d._id } )
                .attr("transform", function(d) { return "translate(" + path.centroid(d) + ")"; });*/
            
            
            neighborhoodPolyGroups = svg.selectAll("g")
              .data(neighborhoodsAll.features)
              .enter()
              .append("g")
              //.attr("g", path)
              //.style("fill", "blue")
              //.style("fill-opacity", (d) => {
              //  return 0.2
              //})

            var neighborhoodDotDensity = neighborhoodPolyGroups.append("path")
              .datum( (d) => {
                console.log(d);
                var numLangs = 0;
                if (d.properties.languages) { numLangs = d.properties.languages.length };
                var multiPoint = 
                                  {
                                  "type": "Feature",
                                    "geometry": {
                                      "type": "MultiPoint",
                                      "coordinates": []
                                    },
                                    "properties": {
                                      "num": "0"
                                    }
                                  }
                multiPoint.geometry.coordinates = dotDensityPoints( numLangs * 6, d.geometry );
                console.log(multiPoint);
                return multiPoint;
              })
              .attr("d", pointPath)
              .attr("fill", "red");
              
            
            // update the path using the current transform
            function update() {
              console.log('called update')
              neighborhoodDotDensity.attr("d", pointPath);
              //neighborhoodCenters.attr("transform", function(d) {return "translate(" + path.centroid(d) + ")"; });
              //neighborhoodPolys.attr("d", path);
              //console.log('update')
            }
            
            function projectPoint(x, y) {
                var point = map.latLngToLayerPoint(new L.LatLng(y, x));
              
                //var point2 = map.project(new mapboxgl.LngLat(lon, lat));
                this.stream.point(point.x, point.y);
            }   
                        
            map.on("viewreset", update)
            map.on("movestart", function(){
            svg.classed("hidden", true);
            });	
            map.on("rotate", function(){
            svg.classed("hidden", true);
            });	
            map.on("moveend", function(){
            update()
            svg.classed("hidden", false);
            })
            update();                                    
        }// draws base map, colored bands, sets hover behavior, calls connectTwoElements
        
        function updateGlobe( item ) {
          //console.log(item);
          d3.select('#globe-target').selectAll('*').remove(); // clear globe
          var rotation = [ -item.longitude, -item.latitude ];
          var width = window.innerWidth,
              height = window.innerHeight;
              
          init();

          function init(){
              // set projection 
              var projection = d3.geoOrthographic()
                  .scale(60)
                  .rotate( rotation )
                  //.center( center )
                  .translate([0, 0])
                  .clipAngle(90);

              // initialize path generator - this is a function!
              var path = d3.geoPath()
                  .projection(projection);
                  //.pointRadius(2);

              var globeTarget = d3.select('#globe-target').append("svg")
                  .attr('width', window.innerWidth)
                  .attr('height', window.innerHeight)
                  .append("g")
                  .attr("class", "globe-container")
                  .attr("transform", "translate(100, 100)")
                  .on("mouseover", (d, i, n) => {
                    //console.log('globe mouseover')
                    //growGlobe();                                                            
                  });

              //Create the base globe
              var backgroundCircle = globeTarget.append("circle")
                  .attr('cx', 0)
                  .attr('cy', 0)
                  .attr('r', projection.scale())
                  .attr('class', 'globe')
                  .attr("fill", "black")
                  .attr("fill-opacity", "0.5");

              //Add all of the countries to the globe
              var continentPaths = globeTarget.selectAll("path")
                  .data(data.continents)
                  .enter()
                  .append("path")
                  .attr("class", "feature")
                  .attr("fill", "white")
                  .attr("fill-opacity", "0.5")
                  .attr("d", path);  // this is where svg data gets added, based on data transformed through path generator
                  
              //Add marker at the center of the globe 
              var Circle = globeTarget.append("text")
                  .attr('x', 0)
                  .attr('y', 0)
                  .attr('text-anchor', 'middle')
                  .attr('dominant-baseline', 'middle')
                  .attr('font-size', '2em')
                  .attr("fill", "white")
                  .attr("fill-opacity", "1")
                  .text("+")

              var countryList = [];
              item.countries.map( (country) => {
                countryList.push( country.properties.ADMIN );
              });

              //Add list of countries under globe
              var countryList = globeTarget.append("text")
                .attr('x', 0)
                .attr('y', 60)
                .attr('text-anchor', 'middle')
                .attr('dominant-baseline', 'middle')
                .attr("fill", "black")
                .selectAll('tspan')
                .data(countryList)
                .enter()
                .append('tspan')
                .attr('x', 0)
                .attr('dy', 15)
                .text(function(d) { return d });

              }
        }// draws/redraws globe widget for highlighted language
        
        function connectTwoElements( id, from, to, color ) { // draws line between two elements, expects two 2d coordinate pair arrays

            //var target = d3.select(`#ID${id}`);
            var target = d3.select('')  
              
            target.append("path")
              .attr("d", d3.linkHorizontal()
                .source(function () { return [from[0] - to[0], from[1] - to[1]]  })
                .target(function () { return [0, 0] }))
                .attr("stroke", color)
                .attr("stroke-width", '1')
                .attr("fill", "none");

            target.append("text")
              .attr("dy", "1.5em")
              .attr("text-anchor", "middle")
              .style("fill", "white")
              .text(function(d) { return d.properties.NTAName });
              
            target.append("circle")
                .attr("fill", "white")
                .attr("r", 3);
            }
            
        /***************************** DATA LOADING **************************/  
              
        function updateSelectionData(id, callback) {
          getDataSingle( 'languages', id, (result) => {
              var resultObj = result;
              
              
              if (resultObj.countries) {
                getData( 'countries', resultObj.countries, (resultCountries) => {
                  resultObj.countries = resultCountries;
                  data.selected = resultObj;
                  
                  
                })
              }
              if (resultObj.neighborhoods) {
                getData( 'neighborhoods', resultObj.neighborhoods, (resultNeighborhoods) => {
                  resultObj.neighborhoods = resultNeighborhoods;
                  data.selected = resultObj;
                })
              }
              //console.log(resultObj);
              data.selected = resultObj;
              if (callback) callback()
          });
        }
        
        function updateData(mode, input, callback) {
          //console.log('update data called')
          setTimeout(function() {
            if (mode == 'langname' ) {
              getData( 'languages', [], (response) => {  // get main language data
                filterData( input, response, (filterresponse) => {
                  data.languages = filterresponse;
                  getData( 'countries', [], (response) => {
                    data.countries = response;
                    getData( 'neighborhoods', [], (response) => {
                      data.neighborhoods = response;
                      getData( 'continents', [], (response) => {
                        data.continents = response;
                        if (callback) {callback()};
                      })
                    })
                  })
                })
              })
            }
          }, 250);
        }
        
        function filterData(string, data, callback) {
          let results = fuzzy.filter(string, data, searchOptions);
          let matches = results.map(function(el) { return el.original; });          
          callback(matches)
        }
             
        function getData( collection, ids, callback ) { // id is optional
          
          let url = `../${collection}`;
          d3.json(url, function(json){
            if (ids.length > 0) {
              //console.log(ids);
              let filteredJson = []
              
              async.each(
                json,
                
                (item, callback) => {
                  //console.log(ids)
                  //console.log(item._id)
                  //console.log( ids.indexOf(item._id)
                  if ( ids.indexOf(item._id) > -1 ) {
                    filteredJson.push(item);
                  }
                  callback();
        
                }, 
                
                (err, transformed) => {
                  //console.log(filteredJson)
                  callback(filteredJson);
                }
                
              );

            } else {
              //console.log(json);
              callback(json);        
            }
          })
        }
        
        function getDataSingle( collection, id, callback ) {
          let url = `../${collection}/${id}`;
          d3.json(url, function(json){
              //console.log('getdatasingle request')
              //console.log(url)
              //console.log(json)
              callback(json)
          });
        }
        
        /*********************** UTILITY *************************************/
         
        function logResult(input) {
          //console.log(input);
        }
        
        function parseTransform (input) { // convert svg transform string into object
            var a= input.replace(/\s/g,'')
            var b={};
            for (var i in a = a.match(/(\w+\((\-?\d+\.?\d*e?\-?\d*,?)+\))+/g))
            {
                var c = a[i].match(/[\w\.\-]+/g);
                b[c.shift()] = c;
            }
            return b;
        }
        
        function dotDensityPoints( numPts, geoPath ) {  //todo - rewrite without while loop (async)
          var coordArray = [];
          var bounds = d3.geoBounds(geoPath);  // returns [[left, bottom], [right, top]] in lat (top, bottom), lon (left, right)   
          while (coordArray.length < numPts) {
          //for (var i = 0; i < 50; i++ ) {           
              var long = d3.randomUniform(bounds[0][0], bounds[1][0])()
              var lat = d3.randomUniform(bounds[0][1], bounds[1][1])()
              if (d3.geoContains(geoPath, [long, lat])) {
                coordArray.push([long, lat])
              }
          }
          return coordArray
        }
